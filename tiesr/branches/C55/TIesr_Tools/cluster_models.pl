#!/usr/local/bin/perl
#---------------------------------------------------------------- 

 #
 # cluster_models.pl
 #
 # Cluster acoustic match scores.
 #
 # Copyright (C) 2010 Texas Instruments Incorporated - http://www.ti.com/
 #
 # This program is free software; you can redistribute it and/or modify 
 # it under the terms of the GNU Lesser General Public License as
 # published by the Free Software Foundation version 2.1 of the License.
 #
 # This program is distributed "as is" WITHOUT ANY WARRANTY of any kind,
 # whether express or implied; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 # Lesser General Public License for more details.
 #
 
#----------------------------------------------------------------  

$USAGE = "
cluster_models -Help -r recfile -o treefile";


$DOCUMENTATION = " 

This perl script is used to cluster the acoustic match scores from the
output of the htk_model_compare.pl perl script, and to output a 
TIesr-compatible hierarchical tree file that clusters models according
to their similarity. The arguments to the script are as follows:

-Help : Output this help info.
-r    : recognition score text file name generated by htk_model_compare.pl
-o    : Output binary tree file name
-le   : Flag indicating to output littleendian compatible binary file
";

#----------------------------------------------------------------

use Getopt::Long;

use Algorithm::Cluster;

# Get script parameters
GetOptions( 'Help' => \$outdoc,
	    'r=s' => \$recfile,
            'o=s' => \$outfile,
	    'le'  => \$littleendian
	    );


# Output documentation if requested
if( $outdoc )
{
    print "$USAGE\n";
    print "$DOCUMENTATION\n";
    exit 1;
}


# Read in the list of scores created by htk model compare
die "$0 : Invalid dist file\n" unless -f $recfile;
open( SCORE, "<$recfile" ) or die "$0 : Can not open $recfile\n";

@scores=();

while( <SCORE> )
{
    chomp;

    @data = split (" ");

    push @scores, $data[5];
}
close( SCORE );


# Put scores into a lower triangular square array, 
# averaging the corresponding entries. This is the
# format that treecluster requires.
$numphones = int ( sqrt( scalar @scores) + 0.5 );
die "$0 : Invalid number of scores\n"
    unless $numphones*$numphones == scalar( @scores );

# First row is empty
$sarray[0] = [];

# Form lower triangular part of score array
for( $row = 1; $row < $numphones; $row++ )
{
    for( $col = 0; $col < $row; $col++ )
    {
	$sarray[$row][$col] = 
	    -( $scores[$row*$numphones + $col] + 
	       $scores[$col*$numphones + $row ]  )/2;
    }
}


# Cluster the model scores to determine similar models
%params = ( data => \@sarray,
	    method => 'm' );

$tree = Algorithm::Cluster::treecluster( %params );


# Locate the top node of the tree. This appears to be the
# last node of $tree, but do not know if this is certain.
$nnodes = $tree->length;

# Create hash containing all negative node numbers
@survive{(-$nnodes) .. -1} = ((-$nnodes) .. -1 );

# Loop over all nodes
for( $ixnode = 0; $ixnode < $nnodes; $ixnode++ )
{
    $node = $tree->get($ixnode);
    $left = $node->left;
    $right = $node->right;
    
    # Remove node numbers from survive hash that are referenced by current node
    delete $survive{$left} if $left < 0  && exists $survive{$left};
    delete $survive{$right} if $right < 0 && exists $survive{$right};
}
# Only the top node is not referenced by any other node
($topnode) = keys(%survive);


# Recursively traverse the tree, determining node structure and
# terminal node to phone mapping.
traverse_tree( $topnode );


# Construct list of left-to-right node indices by tree level for non-terminal nodes
foreach $lev ( 1 .. $maxlevel )
{
    push @levelntlist,  @{$levelntindices[$lev]};
}	

# Make a list to look up ordered non-terminal indices from the original left-to-right
# tree level node indices. Note that the ordered indices are offset by $numphones.
@orderedntindices[ @levelntlist ] = ($numphones .. 2*$numphones-2);

# Define the ordered index of the non-existent parent of the top-level node
$orderedntindices[$numphones-1] = 2*$numphones-1;


# Output the tree in TIesr-compatible binary format
open( OUT, ">$outfile" ) or die "$0 : Could not open $outfile\n";

$format = $littleendian  ?  "v*" : "n*";

# Output number of terminals
print OUT pack $format, $numphones;

# Output left-to-right level-ordered parent index of each terminal
print OUT pack $format, @orderedntindices[ @termparent ];

# Output level-ordered parent index of each non-terminal
@parentntindices = @ntparent[ @levelntlist ];
print OUT pack $format, @orderedntindices[ @parentntindices ];

# Output number of phones
print OUT pack $format, $numphones;

# Output terminal index for each phone.
@termindices[@pmap] = (0 .. $#pmap);
print OUT pack $format, @termindices;

close(OUT);


exit(0); 


#-----------------------------------------------------------------
# traverse_tree

# Traverse the cluster tree depth-first, and left to right. Determine
# the level of each non-terminal node in two-dimensional @array level,
# determine phone to terminal node mapping in array @pmap. Determine
# terminal and non-terminal node indices. Terminal nodes have indices
# of 0 to numphones-1, and non-terminal nodes have indices of
# numphones to 2*numphones-1.  Determine terminal and non-terminal
# node parents.
#---------------------
sub traverse_tree
{
    # Current node number, which is negative
    my $nodenum = shift @_;


    # Convert negative node number to node index. Node indices run from
    # 0 to $numphones-2
    my $nodeindex = -$nodenum - 1;


    # Initialization at start of traversing
    if( $nodenum == $topnode )
    {
	# Top level parent node assigned to non-existing non-terminal index
	$ntparent[$nodeindex] = $nodeindex + 1;

	# Track maximum level of nodes in tree. Terminal nodes are at 
	# level zero.
	$maxlevel = 0;
    }


    # Obtain left and right children of current node
    my $node = $tree->get($nodeindex);
    my $left = $node->left;
    my $right = $node->right;
    my ( $leftlevel, $rightlevel );


    # Decend left child first
    if( $left < 0 )
    {
	# Parent of non-terminal left child node is current node
	my $leftindex = -$left - 1;
	$ntparent[$leftindex] = $nodeindex;

	# Decend to and return level of left child
	$leftlevel = traverse_tree( $left );
    }
    else
    {
	# Left child is terminal node containing phone index
	push @pmap, $left;
 	

	# Parent of child terminal node is current node
	push @termparent, $nodeindex;

	# Terminal node is at level 0
	$leftlevel = 0;
    }


    # Decend right child
    if( $right < 0 )
    {
	# Parent of non-terminal right child node is current node
	my $rightindex = -$right - 1;
	$ntparent[$rightindex] = $nodeindex;

	# Return level of right child
	$rightlevel = traverse_tree( $right );
    }
    else
    {
	# Right child is terminal node containing phone index
	push @pmap, $right;
	

	# Parent of child terminal node is current node
	push @termparent, $nodeindex;

	# Terminal node is at level 0
	$rightlevel = 0;
    }
    
    
    # Determine level of the current node, and keep track of order of 
    # occurrence of nodes of each level, left to right.
    my $curlevel = $leftlevel >= $rightlevel ?  $leftlevel  :  $rightlevel;
    $curlevel++;

    push @{$levelntindices[$curlevel]}, $nodeindex;

    # Track maximum level
    $maxlevel = $curlevel if $maxlevel < $curlevel;

    return $curlevel;
}



